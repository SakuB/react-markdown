{"version":3,"sources":["webpack:///editor.min.js","webpack:///webpack/bootstrap 5ec8d881bec3aa11bfe9","webpack:///./src/js/editor.main.js","webpack:///external \"React\"","webpack:///./src/js/components/form.react.jsx","webpack:///./src/js/components/taginput.react.jsx","webpack:///./src/js/stores/taginput.store.js","webpack:///./~/reflux/index.js","webpack:///./~/reflux/src/index.js","webpack:///./~/reflux/src/listenTo.js","webpack:///./~/reflux/src/ActionMethods.js","webpack:///./~/reflux/src/ListenerMethods.js","webpack:///./~/reflux/src/utils.js","webpack:///./~/reflux/~/eventemitter3/index.js","webpack:///./~/reflux/~/native-promise-only/npo.js","webpack:///./~/node-libs-browser/~/timers-browserify/main.js","webpack:///./~/node-libs-browser/~/process/browser.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./~/reflux/src/joins.js","webpack:///./~/reflux/src/createStore.js","webpack:///./~/reflux/src/Keep.js","webpack:///./~/reflux/src/mixer.js","webpack:///./~/reflux/src/bindMethods.js","webpack:///./~/reflux/src/PublisherMethods.js","webpack:///./~/reflux/src/StoreMethods.js","webpack:///./~/reflux/src/createAction.js","webpack:///./~/reflux/src/connect.js","webpack:///./~/reflux/src/connectFilter.js","webpack:///./~/reflux/src/ListenerMixin.js","webpack:///./~/reflux/src/listenToMany.js","webpack:///./src/js/actions/taginput.action.js","webpack:///./src/js/components/editor.react.jsx","webpack:///external \"marked\""],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_react","_react2","_componentsFormReact","_componentsFormReact2","mount","document","getElementById","render","createElement","React","Object","defineProperty","value","_taginputReact","_taginputReact2","_editorReact","_editorReact2","createClass","displayName","_storesTaginputStore","_storesTaginputStore2","_actionsTaginputAction","_actionsTaginputAction2","getInitialState","tags","this","props","componentDidMount","input","findDOMNode","refs","_initialInputWidth","_getElementWidth","setTags","state","listen","_updateView","map","tag","i","key","className","onClick","removeTag","_click","type","ref","onKeyDown","_keyDown","onKeyUp","_keyUp","setState","focus","e","keyCode","preventDefault","val","trim","style","width","addTag","hidden","textContent","wInput","wHidden","elem","rect","getBoundingClientRect","right","left","getTags","newTags","prototype","toString","_reflux","_reflux2","createStore","init","listenToMany","onAddTag","newTag","indexOf","push","trigger","onRemoveTag","index","length","splice","ActionMethods","ListenerMethods","PublisherMethods","StoreMethods","createAction","connect","connectFilter","ListenerMixin","listenTo","maker","staticJoinCreator","joinTrailing","all","joinLeading","joinStrict","joinConcat","_","EventEmitter","Promise","createActions","definitions","actions","k","hasOwnProperty","actionName","isObject","setEventEmitter","ctx","setPromise","setPromiseFactory","factory","createPromise","nextTick","__keep","Function","bind","console","error","Reflux","listenable","callback","initial","componentWillUnmount","stopListeningToAll","instanceJoinCreator","mapChildListenables","childName","children","flattenListenables","listenables","flattened","childMap","childKey","childListenable","capitalize","hasListener","j","listener","subscriptions","concat","allListenables","cbname","callbackName","localname","undefined","validateListening","isFunction","defaultCallback","desub","unsubscriber","subscriptionobj","subs","throwIf","fetchInitialState","stop","stopListeningTo","sub","remaining","me","data","then","apply","arguments","extend","source","prop","getOwnPropertyDescriptor","propertyDescriptor","setTimeout","string","charAt","toUpperCase","slice","object","keys","vals","o","resolver","isArguments","msg","Error","EE","fn","context","once","_events","listeners","event","l","ee","Array","emit","a1","a2","a3","a4","a5","args","len","removeListener","on","events","removeAllListeners","off","addListener","setMaxListeners","EventEmitter2","EventEmitter3","__WEBPACK_AMD_DEFINE_RESULT__","global","setImmediate","t","n","add","h","y","drain","chain","success","failure","r","reject","promise","TypeError","resolve","u","a","triggered","def","f","s","__NPO__","constructor","writable","configurable","d","self","next","g","clearImmediate","Timeout","clearFn","_id","_clearFn","immediateIds","nextImmediateId","window","clearTimeout","setInterval","clearInterval","timeout","close","unref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","run","Item","fun","array","noop","process","title","browser","env","argv","version","versions","binding","name","cwd","chdir","dir","umask","__webpack_amd_options__","makeStopper","subobj","cancels","reset","join","listenablesEmitted","numberOfListenables","newListener","callargs","strategy","emitIfAllListenablesEmitted","strategyMethodNames","strict","first","last","pop","Keep","mixer","allowed","preEmit","shouldEmit","bindMethods","definition","Store","arr","emitter","eventLabel","store","createdStores","createdActions","composed","updated","mixDef","mixin","mixed","mixins","forEach","subMixin","composable","reduce","newValue","some","property","bindContext","eventHandler","aborted","canHandlePromise","response","completed","failed","listenAndPromise","willCallPromise","removeListen","pre","triggerAsync","triggerPromise","old_promise_method","removeSuccess","removeFailed","asyncResult","childActions","_isAction","functor","sync","cb","v","filterFunc","result","_marked","_marked2","__html","textControl","editor","previewControl","preview","onChange","_onChange","dangerouslySetInnerHTML","_this","_ltr","marked"],"mappings":"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","file":"editor.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _componentsFormReact = __webpack_require__(2);\n\t\n\tvar _componentsFormReact2 = _interopRequireDefault(_componentsFormReact);\n\t\n\tvar mount = document.getElementById('editor');\n\t_react2['default'].render(_react2['default'].createElement(_componentsFormReact2['default'], null), mount);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = React;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _taginputReact = __webpack_require__(3);\n\t\n\tvar _taginputReact2 = _interopRequireDefault(_taginputReact);\n\t\n\tvar _editorReact = __webpack_require__(29);\n\t\n\tvar _editorReact2 = _interopRequireDefault(_editorReact);\n\t\n\texports['default'] = _react2['default'].createClass({\n\t  displayName: 'form.react',\n\t\n\t  render: function render() {\n\t    return _react2['default'].createElement(\n\t      'form',\n\t      null,\n\t      _react2['default'].createElement(_taginputReact2['default'], null),\n\t      _react2['default'].createElement(_editorReact2['default'], null)\n\t    );\n\t  }\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../../typings/react/react.d.ts\"/>\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _storesTaginputStore = __webpack_require__(4);\n\t\n\tvar _storesTaginputStore2 = _interopRequireDefault(_storesTaginputStore);\n\t\n\tvar _actionsTaginputAction = __webpack_require__(28);\n\t\n\tvar _actionsTaginputAction2 = _interopRequireDefault(_actionsTaginputAction);\n\t\n\texports['default'] = _react2['default'].createClass({\n\t  displayName: 'taginput.react',\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      tags: this.props.tags || []\n\t    };\n\t  },\n\t  componentDidMount: function componentDidMount() {\n\t    var input = _react2['default'].findDOMNode(this.refs.input);\n\t    this._initialInputWidth = this._getElementWidth(input);\n\t\n\t    // init tags\n\t    (0, _storesTaginputStore.setTags)(this.state.tags);\n\t    _storesTaginputStore2['default'].listen(this._updateView);\n\t  },\n\t  render: function render() {\n\t    var that = this;\n\t    var tags = this.state.tags.map(function (tag, i) {\n\t      return _react2['default'].createElement(\n\t        'span',\n\t        { key: i, className: 'tag' },\n\t        tag,\n\t        _react2['default'].createElement(\n\t          'span',\n\t          { className: 'tag-remove', onClick: function () {\n\t              _actionsTaginputAction2['default'].removeTag(i);\n\t            } },\n\t          ' X'\n\t        )\n\t      );\n\t    });\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'tag-input', onClick: this._click },\n\t      tags,\n\t      _react2['default'].createElement('input', { type: 'text', ref: 'input', onKeyDown: this._keyDown, onKeyUp: this._keyUp }),\n\t      _react2['default'].createElement('span', { className: 'hidden', ref: 'hidden' })\n\t    );\n\t  },\n\t  _updateView: function _updateView(tags) {\n\t    this.setState({ tags: tags });\n\t  },\n\t  _click: function _click() {\n\t    var input = _react2['default'].findDOMNode(this.refs.input);\n\t    input.focus();\n\t  },\n\t  _keyDown: function _keyDown(e) {\n\t    var input = _react2['default'].findDOMNode(this.refs.input);\n\t\n\t    switch (e.keyCode) {\n\t      case 188:\n\t        {\n\t          // add tag if ','\n\t          e.preventDefault(); // prevent the input of ','\n\t\n\t          var val = input.value.trim();\n\t          input.value = '';\n\t          input.style.width = this._initialInputWidth + 'px';\n\t          _actionsTaginputAction2['default'].addTag(val);\n\t          break;\n\t        };\n\t      case 8:\n\t        {\n\t          // remove tag if 'del'\n\t          if (input.value == '') _actionsTaginputAction2['default'].removeTag();\n\t          break;\n\t        };\n\t      default:\n\t        {};\n\t    }\n\t  },\n\t  _keyUp: function _keyUp(e) {\n\t    var input = _react2['default'].findDOMNode(this.refs.input);\n\t    var hidden = _react2['default'].findDOMNode(this.refs.hidden);\n\t\n\t    hidden.textContent = input.value;\n\t\n\t    var wInput = this._getElementWidth(input);\n\t    var wHidden = this._getElementWidth(hidden);\n\t    if (wHidden + 20 > wInput) {\n\t      input.style.width = wInput + 20 + 'px';\n\t    }\n\t  },\n\t  _getElementWidth: function _getElementWidth(elem) {\n\t    var rect = elem.getBoundingClientRect();\n\t    return rect.right - rect.left;\n\t  }\n\t});\n\tmodule.exports = exports['default'];\n\n\t// dynamic adjust input width\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.getTags = getTags;\n\texports.setTags = setTags;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _reflux = __webpack_require__(5);\n\t\n\tvar _reflux2 = _interopRequireDefault(_reflux);\n\t\n\tvar _actionsTaginputAction = __webpack_require__(28);\n\t\n\tvar _actionsTaginputAction2 = _interopRequireDefault(_actionsTaginputAction);\n\t\n\tvar tags = [];\n\t\n\tfunction getTags() {\n\t  return tags;\n\t}\n\t\n\tfunction setTags(newTags) {\n\t  if (Object.prototype.toString.call(tags) == '[object Array]') {\n\t    tags = newTags;\n\t  }\n\t}\n\t\n\texports['default'] = _reflux2['default'].createStore({\n\t  init: function init() {\n\t    this.listenToMany(_actionsTaginputAction2['default']);\n\t  },\n\t  onAddTag: function onAddTag(newTag) {\n\t    if (newTag && tags.indexOf(newTag) < 0) {\n\t      tags.push(newTag);\n\t      this.trigger(tags);\n\t    }\n\t  },\n\t  onRemoveTag: function onRemoveTag(index) {\n\t    if (typeof index == 'undefined') {\n\t      index = tags.length - 1;\n\t    }\n\t    tags.splice(index, 1);\n\t    this.trigger(tags);\n\t  }\n\t});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6);\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.ActionMethods = __webpack_require__(8);\n\t\n\texports.ListenerMethods = __webpack_require__(9);\n\t\n\texports.PublisherMethods = __webpack_require__(21);\n\t\n\texports.StoreMethods = __webpack_require__(22);\n\t\n\texports.createAction = __webpack_require__(23);\n\t\n\texports.createStore = __webpack_require__(17);\n\t\n\texports.connect = __webpack_require__(24);\n\t\n\texports.connectFilter = __webpack_require__(25);\n\t\n\texports.ListenerMixin = __webpack_require__(26);\n\t\n\texports.listenTo = __webpack_require__(7);\n\t\n\texports.listenToMany = __webpack_require__(27);\n\t\n\t\n\tvar maker = __webpack_require__(16).staticJoinCreator;\n\t\n\texports.joinTrailing = exports.all = maker(\"last\"); // Reflux.all alias for backward compatibility\n\t\n\texports.joinLeading = maker(\"first\");\n\t\n\texports.joinStrict = maker(\"strict\");\n\t\n\texports.joinConcat = maker(\"all\");\n\t\n\tvar _ = __webpack_require__(10);\n\t\n\texports.EventEmitter = _.EventEmitter;\n\t\n\texports.Promise = _.Promise;\n\t\n\t/**\n\t * Convenience function for creating a set of actions\n\t *\n\t * @param definitions the definitions for the actions to be created\n\t * @returns an object with actions of corresponding action names\n\t */\n\texports.createActions = function(definitions) {\n\t    var actions = {};\n\t    for (var k in definitions){\n\t        if (definitions.hasOwnProperty(k)) {\n\t            var val = definitions[k],\n\t                actionName = _.isObject(val) ? k : val;\n\t\n\t            actions[actionName] = exports.createAction(val);\n\t        }\n\t    }\n\t    return actions;\n\t};\n\t\n\t/**\n\t * Sets the eventmitter that Reflux uses\n\t */\n\texports.setEventEmitter = function(ctx) {\n\t    var _ = __webpack_require__(10);\n\t    exports.EventEmitter = _.EventEmitter = ctx;\n\t};\n\t\n\t\n\t/**\n\t * Sets the Promise library that Reflux uses\n\t */\n\texports.setPromise = function(ctx) {\n\t    var _ = __webpack_require__(10);\n\t    exports.Promise = _.Promise = ctx;\n\t};\n\t\n\t\n\t/**\n\t * Sets the Promise factory that creates new promises\n\t * @param {Function} factory has the signature `function(resolver) { return [new Promise]; }`\n\t */\n\texports.setPromiseFactory = function(factory) {\n\t    var _ = __webpack_require__(10);\n\t    _.createPromise = factory;\n\t};\n\t\n\t\n\t/**\n\t * Sets the method used for deferring actions and stores\n\t */\n\texports.nextTick = function(nextTick) {\n\t    var _ = __webpack_require__(10);\n\t    _.nextTick = nextTick;\n\t};\n\t\n\t/**\n\t * Provides the set of created actions and stores for introspection\n\t */\n\texports.__keep = __webpack_require__(18);\n\t\n\t/**\n\t * Warn if Function.prototype.bind not available\n\t */\n\tif (!Function.prototype.bind) {\n\t  console.error(\n\t    'Function.prototype.bind not available. ' +\n\t    'ES5 shim required. ' +\n\t    'https://github.com/spoike/refluxjs#es5'\n\t  );\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Reflux = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\n\t * without having to manually set listeners in the `componentDidMount` method.\n\t *\n\t * @param {Action|Store} listenable An Action or Store that should be\n\t *  listened to.\n\t * @param {Function|String} callback The callback to register as event handler\n\t * @param {Function|String} defaultCallback The callback to register as default handler\n\t * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\n\t */\n\tmodule.exports = function(listenable,callback,initial){\n\t    return {\n\t        /**\n\t         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n\t         * and then make the call to `listenTo` with the arguments provided to the factory function\n\t         */\n\t        componentDidMount: function() {\n\t            for(var m in Reflux.ListenerMethods){\n\t                if (this[m] !== Reflux.ListenerMethods[m]){\n\t                    if (this[m]){\n\t                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenTo!\";\n\t                    }\n\t                    this[m] = Reflux.ListenerMethods[m];\n\t                }\n\t            }\n\t            this.listenTo(listenable,callback,initial);\n\t        },\n\t        /**\n\t         * Cleans up all listener previously registered.\n\t         */\n\t        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n\t    };\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * A module of methods that you want to include in all actions.\n\t * This module is consumed by `createAction`.\n\t */\n\tmodule.exports = {\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10),\n\t    maker = __webpack_require__(16).instanceJoinCreator;\n\t\n\t/**\n\t * Extract child listenables from a parent from their\n\t * children property and return them in a keyed Object\n\t *\n\t * @param {Object} listenable The parent listenable\n\t */\n\tvar mapChildListenables = function(listenable) {\n\t    var i = 0, children = {}, childName;\n\t    for (;i < (listenable.children||[]).length; ++i) {\n\t        childName = listenable.children[i];\n\t        if(listenable[childName]){\n\t            children[childName] = listenable[childName];\n\t        }\n\t    }\n\t    return children;\n\t};\n\t\n\t/**\n\t * Make a flat dictionary of all listenables including their\n\t * possible children (recursively), concatenating names in camelCase.\n\t *\n\t * @param {Object} listenables The top-level listenables\n\t */\n\tvar flattenListenables = function(listenables) {\n\t    var flattened = {};\n\t    for(var key in listenables){\n\t        var listenable = listenables[key];\n\t        var childMap = mapChildListenables(listenable);\n\t\n\t        // recursively flatten children\n\t        var children = flattenListenables(childMap);\n\t\n\t        // add the primary listenable and chilren\n\t        flattened[key] = listenable;\n\t        for(var childKey in children){\n\t            var childListenable = children[childKey];\n\t            flattened[key + _.capitalize(childKey)] = childListenable;\n\t        }\n\t    }\n\t\n\t    return flattened;\n\t};\n\t\n\t/**\n\t * A module of methods related to listening.\n\t */\n\tmodule.exports = {\n\t\n\t    /**\n\t     * An internal utility function used by `validateListening`\n\t     *\n\t     * @param {Action|Store} listenable The listenable we want to search for\n\t     * @returns {Boolean} The result of a recursive search among `this.subscriptions`\n\t     */\n\t    hasListener: function(listenable) {\n\t        var i = 0, j, listener, listenables;\n\t        for (;i < (this.subscriptions||[]).length; ++i) {\n\t            listenables = [].concat(this.subscriptions[i].listenable);\n\t            for (j = 0; j < listenables.length; j++){\n\t                listener = listenables[j];\n\t                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * A convenience method that listens to all listenables in the given object.\n\t     *\n\t     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\n\t     */\n\t    listenToMany: function(listenables){\n\t        var allListenables = flattenListenables(listenables);\n\t        for(var key in allListenables){\n\t            var cbname = _.callbackName(key),\n\t                localname = this[cbname] ? cbname : this[key] ? key : undefined;\n\t            if (localname){\n\t                this.listenTo(allListenables[key],localname,this[cbname+\"Default\"]||this[localname+\"Default\"]||localname);\n\t            }\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Checks if the current context can listen to the supplied listenable\n\t     *\n\t     * @param {Action|Store} listenable An Action or Store that should be\n\t     *  listened to.\n\t     * @returns {String|Undefined} An error message, or undefined if there was no problem.\n\t     */\n\t    validateListening: function(listenable){\n\t        if (listenable === this) {\n\t            return \"Listener is not able to listen to itself\";\n\t        }\n\t        if (!_.isFunction(listenable.listen)) {\n\t            return listenable + \" is missing a listen method\";\n\t        }\n\t        if (listenable.hasListener && listenable.hasListener(this)) {\n\t            return \"Listener cannot listen to this listenable because of circular loop\";\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Sets up a subscription to the given listenable for the context object\n\t     *\n\t     * @param {Action|Store} listenable An Action or Store that should be\n\t     *  listened to.\n\t     * @param {Function|String} callback The callback to register as event handler\n\t     * @param {Function|String} defaultCallback The callback to register as default handler\n\t     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\n\t     */\n\t    listenTo: function(listenable, callback, defaultCallback) {\n\t        var desub, unsubscriber, subscriptionobj, subs = this.subscriptions = this.subscriptions || [];\n\t        _.throwIf(this.validateListening(listenable));\n\t        this.fetchInitialState(listenable, defaultCallback);\n\t        desub = listenable.listen(this[callback]||callback, this);\n\t        unsubscriber = function() {\n\t            var index = subs.indexOf(subscriptionobj);\n\t            _.throwIf(index === -1,'Tried to remove listen already gone from subscriptions list!');\n\t            subs.splice(index, 1);\n\t            desub();\n\t        };\n\t        subscriptionobj = {\n\t            stop: unsubscriber,\n\t            listenable: listenable\n\t        };\n\t        subs.push(subscriptionobj);\n\t        return subscriptionobj;\n\t    },\n\t\n\t    /**\n\t     * Stops listening to a single listenable\n\t     *\n\t     * @param {Action|Store} listenable The action or store we no longer want to listen to\n\t     * @returns {Boolean} True if a subscription was found and removed, otherwise false.\n\t     */\n\t    stopListeningTo: function(listenable){\n\t        var sub, i = 0, subs = this.subscriptions || [];\n\t        for(;i < subs.length; i++){\n\t            sub = subs[i];\n\t            if (sub.listenable === listenable){\n\t                sub.stop();\n\t                _.throwIf(subs.indexOf(sub)!==-1,'Failed to remove listen from subscriptions list!');\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Stops all subscriptions and empties subscriptions array\n\t     */\n\t    stopListeningToAll: function(){\n\t        var remaining, subs = this.subscriptions || [];\n\t        while((remaining=subs.length)){\n\t            subs[0].stop();\n\t            _.throwIf(subs.length!==remaining-1,'Failed to remove listen from subscriptions list!');\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\n\t     * @param {Action|Store} listenable The publisher we want to get initial state from\n\t     * @param {Function|String} defaultCallback The method to receive the data\n\t     */\n\t    fetchInitialState: function (listenable, defaultCallback) {\n\t        defaultCallback = (defaultCallback && this[defaultCallback]) || defaultCallback;\n\t        var me = this;\n\t        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n\t            var data = listenable.getInitialState();\n\t            if (data && _.isFunction(data.then)) {\n\t                data.then(function() {\n\t                    defaultCallback.apply(me, arguments);\n\t                });\n\t            } else {\n\t                defaultCallback.call(this, data);\n\t            }\n\t        }\n\t    },\n\t\n\t    /**\n\t     * The callback will be called once all listenables have triggered at least once.\n\t     * It will be invoked with the last emission from each listenable.\n\t     * @param {...Publishers} publishers Publishers that should be tracked.\n\t     * @param {Function|String} callback The method to call when all publishers have emitted\n\t     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n\t     */\n\t    joinTrailing: maker(\"last\"),\n\t\n\t    /**\n\t     * The callback will be called once all listenables have triggered at least once.\n\t     * It will be invoked with the first emission from each listenable.\n\t     * @param {...Publishers} publishers Publishers that should be tracked.\n\t     * @param {Function|String} callback The method to call when all publishers have emitted\n\t     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n\t     */\n\t    joinLeading: maker(\"first\"),\n\t\n\t    /**\n\t     * The callback will be called once all listenables have triggered at least once.\n\t     * It will be invoked with all emission from each listenable.\n\t     * @param {...Publishers} publishers Publishers that should be tracked.\n\t     * @param {Function|String} callback The method to call when all publishers have emitted\n\t     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n\t     */\n\t    joinConcat: maker(\"all\"),\n\t\n\t    /**\n\t     * The callback will be called once all listenables have triggered.\n\t     * If a callback triggers twice before that happens, an error is thrown.\n\t     * @param {...Publishers} publishers Publishers that should be tracked.\n\t     * @param {Function|String} callback The method to call when all publishers have emitted\n\t     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n\t     */\n\t    joinStrict: maker(\"strict\")\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * isObject, extend, isFunction, isArguments are taken from undescore/lodash in\n\t * order to remove the dependency\n\t */\n\tvar isObject = exports.isObject = function(obj) {\n\t    var type = typeof obj;\n\t    return type === 'function' || type === 'object' && !!obj;\n\t};\n\t\n\texports.extend = function(obj) {\n\t    if (!isObject(obj)) {\n\t        return obj;\n\t    }\n\t    var source, prop;\n\t    for (var i = 1, length = arguments.length; i < length; i++) {\n\t        source = arguments[i];\n\t        for (prop in source) {\n\t            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n\t                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n\t                Object.defineProperty(obj, prop, propertyDescriptor);\n\t            } else {\n\t                obj[prop] = source[prop];\n\t            }\n\t        }\n\t    }\n\t    return obj;\n\t};\n\t\n\texports.isFunction = function(value) {\n\t    return typeof value === 'function';\n\t};\n\t\n\texports.EventEmitter = __webpack_require__(11);\n\t\n\texports.nextTick = function(callback) {\n\t    setTimeout(callback, 0);\n\t};\n\t\n\texports.capitalize = function(string){\n\t    return string.charAt(0).toUpperCase()+string.slice(1);\n\t};\n\t\n\texports.callbackName = function(string){\n\t    return \"on\"+exports.capitalize(string);\n\t};\n\t\n\texports.object = function(keys,vals){\n\t    var o={}, i=0;\n\t    for(;i<keys.length;i++){\n\t        o[keys[i]] = vals[i];\n\t    }\n\t    return o;\n\t};\n\t\n\texports.Promise = __webpack_require__(12);\n\t\n\texports.createPromise = function(resolver) {\n\t    return new exports.Promise(resolver);\n\t};\n\t\n\texports.isArguments = function(value) {\n\t    return typeof value === 'object' && ('callee' in value) && typeof value.length === 'number';\n\t};\n\t\n\texports.throwIf = function(val,msg){\n\t    if (val){\n\t        throw Error(msg||val);\n\t    }\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} once Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Holds the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  if (!this._events || !this._events[event]) return [];\n\t  if (this._events[event].fn) return [this._events[event].fn];\n\t\n\t  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = this._events[event][i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  if (!this._events || !this._events[event]) return false;\n\t\n\t  var listeners = this._events[event]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Functon} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n\t  if (!this._events || !this._events[event]) return this;\n\t\n\t  var listeners = this._events[event]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n\t      events.push(listeners);\n\t    }\n\t    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n\t      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[event] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[event];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[event];\n\t  else this._events = {};\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the module.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\tEventEmitter.EventEmitter2 = EventEmitter;\n\tEventEmitter.EventEmitter3 = EventEmitter;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tmodule.exports = EventEmitter;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*! Native Promise Only\n\t    v0.7.6-a (c) Kyle Simpson\n\t    MIT License: http://getify.mit-license.org\n\t*/\n\t!function(t,n,e){n[t]=n[t]||e(),\"undefined\"!=typeof module&&module.exports?module.exports=n[t]:\"function\"==\"function\"&&__webpack_require__(15)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return n[t]}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}(\"Promise\",\"undefined\"!=typeof global?global:this,function(){\"use strict\";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||\"object\"!=e&&\"function\"!=e||(n=t.then),\"function\"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError(\"Promise-chain cycle\")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u,a=this;if(!a.triggered){a.triggered=!0,a.def&&(a=a.def);try{(c=n(o))?(u=new f(a),c.call(o,function(){r.apply(u,arguments)},function(){i.apply(u,arguments)})):(a.msg=o,a.state=1,a.chain.length>0&&t(e,a))}catch(s){i.call(u||new f(a),s)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if(\"function\"!=typeof n)throw TypeError(\"Not a function\");if(0!==this.__NPO__)throw TypeError(\"Not a promise\");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:\"function\"==typeof n?n:!0,failure:\"function\"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if(\"function\"!=typeof t||\"function\"!=typeof n)throw TypeError(\"Not a function\");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this[\"catch\"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y=\"undefined\"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},\"x\",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},\"constructor\",a,!1);return s(a,\"prototype\",g,!1),s(g,\"__NPO__\",0,!1),s(a,\"resolve\",function(t){var n=this;return t&&\"object\"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");n(t)})}),s(a,\"reject\",function(t){return new this(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");e(t)})}),s(a,\"all\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):0===t.length?n.resolve([]):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,\"race\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");c(n,t,function(t,n){e(n)},o)})}),a});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(13).setImmediate))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(14).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13).setImmediate, __webpack_require__(13).clearImmediate))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            currentQueue[queueIndex].run();\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Internal module used to create static and instance join methods\n\t */\n\t\n\tvar slice = Array.prototype.slice,\n\t    _ = __webpack_require__(10),\n\t    createStore = __webpack_require__(17),\n\t    strategyMethodNames = {\n\t        strict: \"joinStrict\",\n\t        first: \"joinLeading\",\n\t        last: \"joinTrailing\",\n\t        all: \"joinConcat\"\n\t    };\n\t\n\t/**\n\t * Used in `index.js` to create the static join methods\n\t * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n\t * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\n\t */\n\texports.staticJoinCreator = function(strategy){\n\t    return function(/* listenables... */) {\n\t        var listenables = slice.call(arguments);\n\t        return createStore({\n\t            init: function(){\n\t                this[strategyMethodNames[strategy]].apply(this,listenables.concat(\"triggerAsync\"));\n\t            }\n\t        });\n\t    };\n\t};\n\t\n\t/**\n\t * Used in `ListenerMethods.js` to create the instance join methods\n\t * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n\t * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\n\t */\n\texports.instanceJoinCreator = function(strategy){\n\t    return function(/* listenables..., callback*/){\n\t        _.throwIf(arguments.length < 3,'Cannot create a join with less than 2 listenables!');\n\t        var listenables = slice.call(arguments),\n\t            callback = listenables.pop(),\n\t            numberOfListenables = listenables.length,\n\t            join = {\n\t                numberOfListenables: numberOfListenables,\n\t                callback: this[callback]||callback,\n\t                listener: this,\n\t                strategy: strategy\n\t            }, i, cancels = [], subobj;\n\t        for (i = 0; i < numberOfListenables; i++) {\n\t            _.throwIf(this.validateListening(listenables[i]));\n\t        }\n\t        for (i = 0; i < numberOfListenables; i++) {\n\t            cancels.push(listenables[i].listen(newListener(i,join),this));\n\t        }\n\t        reset(join);\n\t        subobj = {listenable: listenables};\n\t        subobj.stop = makeStopper(subobj,cancels,this);\n\t        this.subscriptions = (this.subscriptions || []).concat(subobj);\n\t        return subobj;\n\t    };\n\t};\n\t\n\t// ---- internal join functions ----\n\t\n\tfunction makeStopper(subobj,cancels,context){\n\t    return function() {\n\t        var i, subs = context.subscriptions,\n\t            index = (subs ? subs.indexOf(subobj) : -1);\n\t        _.throwIf(index === -1,'Tried to remove join already gone from subscriptions list!');\n\t        for(i=0;i < cancels.length; i++){\n\t            cancels[i]();\n\t        }\n\t        subs.splice(index, 1);\n\t    };\n\t}\n\t\n\tfunction reset(join) {\n\t    join.listenablesEmitted = new Array(join.numberOfListenables);\n\t    join.args = new Array(join.numberOfListenables);\n\t}\n\t\n\tfunction newListener(i,join) {\n\t    return function() {\n\t        var callargs = slice.call(arguments);\n\t        if (join.listenablesEmitted[i]){\n\t            switch(join.strategy){\n\t                case \"strict\": throw new Error(\"Strict join failed because listener triggered twice.\");\n\t                case \"last\": join.args[i] = callargs; break;\n\t                case \"all\": join.args[i].push(callargs);\n\t            }\n\t        } else {\n\t            join.listenablesEmitted[i] = true;\n\t            join.args[i] = (join.strategy===\"all\"?[callargs]:callargs);\n\t        }\n\t        emitIfAllListenablesEmitted(join);\n\t    };\n\t}\n\t\n\tfunction emitIfAllListenablesEmitted(join) {\n\t    for (var i = 0; i < join.numberOfListenables; i++) {\n\t        if (!join.listenablesEmitted[i]) {\n\t            return;\n\t        }\n\t    }\n\t    join.callback.apply(join.listener,join.args);\n\t    reset(join);\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10),\n\t    Reflux = __webpack_require__(6),\n\t    Keep = __webpack_require__(18),\n\t    mixer = __webpack_require__(19),\n\t    allowed = {preEmit:1,shouldEmit:1},\n\t    bindMethods = __webpack_require__(20);\n\t\n\t/**\n\t * Creates an event emitting Data Store. It is mixed in with functions\n\t * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\n\t * and `shouldEmit` may be overridden in the definition object.\n\t *\n\t * @param {Object} definition The data store object definition\n\t * @returns {Store} A data store instance\n\t */\n\tmodule.exports = function(definition) {\n\t\n\t    definition = definition || {};\n\t\n\t    for(var a in Reflux.StoreMethods){\n\t        if (!allowed[a] && (Reflux.PublisherMethods[a] || Reflux.ListenerMethods[a])){\n\t            throw new Error(\"Cannot override API method \" + a +\n\t                \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n\t            );\n\t        }\n\t    }\n\t\n\t    for(var d in definition){\n\t        if (!allowed[d] && (Reflux.PublisherMethods[d] || Reflux.ListenerMethods[d])){\n\t            throw new Error(\"Cannot override API method \" + d +\n\t                \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n\t            );\n\t        }\n\t    }\n\t\n\t    definition = mixer(definition);\n\t\n\t    function Store() {\n\t        var i=0, arr;\n\t        this.subscriptions = [];\n\t        this.emitter = new _.EventEmitter();\n\t        this.eventLabel = \"change\";\n\t        bindMethods(this, definition);\n\t        if (this.init && _.isFunction(this.init)) {\n\t            this.init();\n\t        }\n\t        if (this.listenables){\n\t            arr = [].concat(this.listenables);\n\t            for(;i < arr.length;i++){\n\t                this.listenToMany(arr[i]);\n\t            }\n\t        }\n\t    }\n\t\n\t    _.extend(Store.prototype, Reflux.ListenerMethods, Reflux.PublisherMethods, Reflux.StoreMethods, definition);\n\t\n\t    var store = new Store();\n\t    Keep.createdStores.push(store);\n\t\n\t    return store;\n\t};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.createdStores = [];\n\t\n\texports.createdActions = [];\n\t\n\texports.reset = function() {\n\t    while(exports.createdStores.length) {\n\t        exports.createdStores.pop();\n\t    }\n\t    while(exports.createdActions.length) {\n\t        exports.createdActions.pop();\n\t    }\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10);\n\t\n\tmodule.exports = function mix(def) {\n\t    var composed = {\n\t        init: [],\n\t        preEmit: [],\n\t        shouldEmit: []\n\t    };\n\t\n\t    var updated = (function mixDef(mixin) {\n\t        var mixed = {};\n\t        if (mixin.mixins) {\n\t            mixin.mixins.forEach(function (subMixin) {\n\t                _.extend(mixed, mixDef(subMixin));\n\t            });\n\t        }\n\t        _.extend(mixed, mixin);\n\t        Object.keys(composed).forEach(function (composable) {\n\t            if (mixin.hasOwnProperty(composable)) {\n\t                composed[composable].push(mixin[composable]);\n\t            }\n\t        });\n\t        return mixed;\n\t    }(def));\n\t\n\t    if (composed.init.length > 1) {\n\t        updated.init = function () {\n\t            var args = arguments;\n\t            composed.init.forEach(function (init) {\n\t                init.apply(this, args);\n\t            }, this);\n\t        };\n\t    }\n\t    if (composed.preEmit.length > 1) {\n\t        updated.preEmit = function () {\n\t            return composed.preEmit.reduce(function (args, preEmit) {\n\t                var newValue = preEmit.apply(this, args);\n\t                return newValue === undefined ? args : [newValue];\n\t            }.bind(this), arguments);\n\t        };\n\t    }\n\t    if (composed.shouldEmit.length > 1) {\n\t        updated.shouldEmit = function () {\n\t            var args = arguments;\n\t            return !composed.shouldEmit.some(function (shouldEmit) {\n\t                return !shouldEmit.apply(this, args);\n\t            }, this);\n\t        };\n\t    }\n\t    Object.keys(composed).forEach(function (composable) {\n\t        if (composed[composable].length === 1) {\n\t            updated[composable] = composed[composable][0];\n\t        }\n\t    });\n\t\n\t    return updated;\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(store, definition) {\n\t  for (var name in definition) {\n\t    if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n\t        var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);\n\t\n\t        if (!propertyDescriptor.value || typeof propertyDescriptor.value !== 'function' || !definition.hasOwnProperty(name)) {\n\t            continue;\n\t        }\n\t\n\t        store[name] = definition[name].bind(store);\n\t    } else {\n\t        var property = definition[name];\n\t\n\t        if (typeof property !== 'function' || !definition.hasOwnProperty(name)) {\n\t            continue;\n\t        }\n\t\n\t        store[name] = property.bind(store);\n\t    }\n\t  }\n\t\n\t  return store;\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10);\n\t\n\t/**\n\t * A module of methods for object that you want to be able to listen to.\n\t * This module is consumed by `createStore` and `createAction`\n\t */\n\tmodule.exports = {\n\t\n\t    /**\n\t     * Hook used by the publisher that is invoked before emitting\n\t     * and before `shouldEmit`. The arguments are the ones that the action\n\t     * is invoked with. If this function returns something other than\n\t     * undefined, that will be passed on as arguments for shouldEmit and\n\t     * emission.\n\t     */\n\t    preEmit: function() {},\n\t\n\t    /**\n\t     * Hook used by the publisher after `preEmit` to determine if the\n\t     * event should be emitted with given arguments. This may be overridden\n\t     * in your application, default implementation always returns true.\n\t     *\n\t     * @returns {Boolean} true if event should be emitted\n\t     */\n\t    shouldEmit: function() { return true; },\n\t\n\t    /**\n\t     * Subscribes the given callback for action triggered\n\t     *\n\t     * @param {Function} callback The callback to register as event handler\n\t     * @param {Mixed} [optional] bindContext The context to bind the callback with\n\t     * @returns {Function} Callback that unsubscribes the registered event handler\n\t     */\n\t    listen: function(callback, bindContext) {\n\t        bindContext = bindContext || this;\n\t        var eventHandler = function(args) {\n\t            if (aborted){\n\t                return;\n\t            }\n\t            callback.apply(bindContext, args);\n\t        }, me = this, aborted = false;\n\t        this.emitter.addListener(this.eventLabel, eventHandler);\n\t        return function() {\n\t            aborted = true;\n\t            me.emitter.removeListener(me.eventLabel, eventHandler);\n\t        };\n\t    },\n\t\n\t    /**\n\t     * Attach handlers to promise that trigger the completed and failed\n\t     * child publishers, if available.\n\t     *\n\t     * @param {Object} The promise to attach to\n\t     */\n\t    promise: function(promise) {\n\t        var me = this;\n\t\n\t        var canHandlePromise =\n\t            this.children.indexOf('completed') >= 0 &&\n\t            this.children.indexOf('failed') >= 0;\n\t\n\t        if (!canHandlePromise){\n\t            throw new Error('Publisher must have \"completed\" and \"failed\" child publishers');\n\t        }\n\t\n\t        promise.then(function(response) {\n\t            return me.completed(response);\n\t        }, function(error) {\n\t            return me.failed(error);\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Subscribes the given callback for action triggered, which should\n\t     * return a promise that in turn is passed to `this.promise`\n\t     *\n\t     * @param {Function} callback The callback to register as event handler\n\t     */\n\t    listenAndPromise: function(callback, bindContext) {\n\t        var me = this;\n\t        bindContext = bindContext || this;\n\t        this.willCallPromise = (this.willCallPromise || 0) + 1;\n\t\n\t        var removeListen = this.listen(function() {\n\t\n\t            if (!callback) {\n\t                throw new Error('Expected a function returning a promise but got ' + callback);\n\t            }\n\t\n\t            var args = arguments,\n\t                promise = callback.apply(bindContext, args);\n\t            return me.promise.call(me, promise);\n\t        }, bindContext);\n\t\n\t        return function () {\n\t          me.willCallPromise--;\n\t          removeListen.call(me);\n\t        };\n\t\n\t    },\n\t\n\t    /**\n\t     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\n\t     */\n\t    trigger: function() {\n\t        var args = arguments,\n\t            pre = this.preEmit.apply(this, args);\n\t        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n\t        if (this.shouldEmit.apply(this, args)) {\n\t            this.emitter.emit(this.eventLabel, args);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Tries to publish the event on the next tick\n\t     */\n\t    triggerAsync: function(){\n\t        var args = arguments,me = this;\n\t        _.nextTick(function() {\n\t            me.trigger.apply(me, args);\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Returns a Promise for the triggered action\n\t     *\n\t     * @return {Promise}\n\t     *   Resolved by completed child action.\n\t     *   Rejected by failed child action.\n\t     *   If listenAndPromise'd, then promise associated to this trigger.\n\t     *   Otherwise, the promise is for next child action completion.\n\t     */\n\t    triggerPromise: function(){\n\t        var me = this;\n\t        var args = arguments;\n\t\n\t        var canHandlePromise =\n\t            this.children.indexOf('completed') >= 0 &&\n\t            this.children.indexOf('failed') >= 0;\n\t\n\t        var promise = _.createPromise(function(resolve, reject) {\n\t            // If `listenAndPromise` is listening\n\t            // patch `promise` w/ context-loaded resolve/reject\n\t            if (me.willCallPromise) {\n\t                _.nextTick(function() {\n\t                    var old_promise_method = me.promise;\n\t                    me.promise = function (promise) {\n\t                        promise.then(resolve, reject);\n\t                        // Back to your regularly schedule programming.\n\t                        me.promise = old_promise_method;\n\t                        return me.promise.apply(me, arguments);\n\t                    };\n\t                    me.trigger.apply(me, args);\n\t                });\n\t                return;\n\t            }\n\t\n\t            if (canHandlePromise) {\n\t                var removeSuccess = me.completed.listen(function(args) {\n\t                    removeSuccess();\n\t                    removeFailed();\n\t                    resolve(args);\n\t                });\n\t\n\t                var removeFailed = me.failed.listen(function(args) {\n\t                    removeSuccess();\n\t                    removeFailed();\n\t                    reject(args);\n\t                });\n\t            }\n\t\n\t            me.triggerAsync.apply(me, args);\n\t\n\t            if (!canHandlePromise) {\n\t                resolve();\n\t            }\n\t        });\n\t\n\t        return promise;\n\t    }\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * A module of methods that you want to include in all stores.\n\t * This module is consumed by `createStore`.\n\t */\n\tmodule.exports = {\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10),\n\t    Reflux = __webpack_require__(6),\n\t    Keep = __webpack_require__(18),\n\t    allowed = {preEmit:1,shouldEmit:1};\n\t\n\t/**\n\t * Creates an action functor object. It is mixed in with functions\n\t * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\n\t * be overridden in the definition object.\n\t *\n\t * @param {Object} definition The action object definition\n\t */\n\tvar createAction = function(definition) {\n\t\n\t    definition = definition || {};\n\t    if (!_.isObject(definition)){\n\t        definition = {actionName: definition};\n\t    }\n\t\n\t    for(var a in Reflux.ActionMethods){\n\t        if (!allowed[a] && Reflux.PublisherMethods[a]) {\n\t            throw new Error(\"Cannot override API method \" + a +\n\t                \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\"\n\t            );\n\t        }\n\t    }\n\t\n\t    for(var d in definition){\n\t        if (!allowed[d] && Reflux.PublisherMethods[d]) {\n\t            throw new Error(\"Cannot override API method \" + d +\n\t                \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\"\n\t            );\n\t        }\n\t    }\n\t\n\t    definition.children = definition.children || [];\n\t    if (definition.asyncResult){\n\t        definition.children = definition.children.concat([\"completed\",\"failed\"]);\n\t    }\n\t\n\t    var i = 0, childActions = {};\n\t    for (; i < definition.children.length; i++) {\n\t        var name = definition.children[i];\n\t        childActions[name] = createAction(name);\n\t    }\n\t\n\t    var context = _.extend({\n\t        eventLabel: \"action\",\n\t        emitter: new _.EventEmitter(),\n\t        _isAction: true\n\t    }, Reflux.PublisherMethods, Reflux.ActionMethods, definition);\n\t\n\t    var functor = function() {\n\t        return functor[functor.sync?\"trigger\":\"triggerPromise\"].apply(functor, arguments);\n\t    };\n\t\n\t    _.extend(functor,childActions,context);\n\t\n\t    Keep.createdActions.push(functor);\n\t\n\t    return functor;\n\t\n\t};\n\t\n\tmodule.exports = createAction;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Reflux = __webpack_require__(6),\n\t    _ = __webpack_require__(10);\n\t\n\tmodule.exports = function(listenable,key){\n\t    return {\n\t        getInitialState: function(){\n\t            if (!_.isFunction(listenable.getInitialState)) {\n\t                return {};\n\t            } else if (key === undefined) {\n\t                return listenable.getInitialState();\n\t            } else {\n\t                return _.object([key],[listenable.getInitialState()]);\n\t            }\n\t        },\n\t        componentDidMount: function(){\n\t            _.extend(this,Reflux.ListenerMethods);\n\t            var me = this, cb = (key === undefined ? this.setState : function(v){me.setState(_.object([key],[v]));});\n\t            this.listenTo(listenable,cb);\n\t        },\n\t        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n\t    };\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Reflux = __webpack_require__(6),\n\t  _ = __webpack_require__(10);\n\t\n\tmodule.exports = function(listenable, key, filterFunc) {\n\t    filterFunc = _.isFunction(key) ? key : filterFunc;\n\t    return {\n\t        getInitialState: function() {\n\t            if (!_.isFunction(listenable.getInitialState)) {\n\t                return {};\n\t            } else if (_.isFunction(key)) {\n\t                return filterFunc.call(this, listenable.getInitialState());\n\t            } else {\n\t                // Filter initial payload from store.\n\t                var result = filterFunc.call(this, listenable.getInitialState());\n\t                if (result) {\n\t                  return _.object([key], [result]);\n\t                } else {\n\t                  return {};\n\t                }\n\t            }\n\t        },\n\t        componentDidMount: function() {\n\t            _.extend(this, Reflux.ListenerMethods);\n\t            var me = this;\n\t            var cb = function(value) {\n\t                if (_.isFunction(key)) {\n\t                    me.setState(filterFunc.call(me, value));\n\t                } else {\n\t                    var result = filterFunc.call(me, value);\n\t                    me.setState(_.object([key], [result]));\n\t                }\n\t            };\n\t\n\t            this.listenTo(listenable, cb);\n\t        },\n\t        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n\t    };\n\t};\n\t\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(10),\n\t    ListenerMethods = __webpack_require__(9);\n\t\n\t/**\n\t * A module meant to be consumed as a mixin by a React component. Supplies the methods from\n\t * `ListenerMethods` mixin and takes care of teardown of subscriptions.\n\t * Note that if you're using the `connect` mixin you don't need this mixin, as connect will\n\t * import everything this mixin contains!\n\t */\n\tmodule.exports = _.extend({\n\t\n\t    /**\n\t     * Cleans up all listener previously registered.\n\t     */\n\t    componentWillUnmount: ListenerMethods.stopListeningToAll\n\t\n\t}, ListenerMethods);\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Reflux = __webpack_require__(6);\n\t\n\t/**\n\t * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\n\t * without having to manually set listeners in the `componentDidMount` method. This version is used\n\t * to automatically set up a `listenToMany` call.\n\t *\n\t * @param {Object} listenables An object of listenables\n\t * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\n\t */\n\tmodule.exports = function(listenables){\n\t    return {\n\t        /**\n\t         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n\t         * and then make the call to `listenTo` with the arguments provided to the factory function\n\t         */\n\t        componentDidMount: function() {\n\t            for(var m in Reflux.ListenerMethods){\n\t                if (this[m] !== Reflux.ListenerMethods[m]){\n\t                    if (this[m]){\n\t                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenToMany!\";\n\t                    }\n\t                    this[m] = Reflux.ListenerMethods[m];\n\t                }\n\t            }\n\t            this.listenToMany(listenables);\n\t        },\n\t        /**\n\t         * Cleans up all listener previously registered.\n\t         */\n\t        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n\t    };\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _reflux = __webpack_require__(5);\n\t\n\tvar _reflux2 = _interopRequireDefault(_reflux);\n\t\n\texports['default'] = _reflux2['default'].createActions(['addTag', 'removeTag']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _marked = __webpack_require__(30);\n\t\n\tvar _marked2 = _interopRequireDefault(_marked);\n\t\n\texports['default'] = _react2['default'].createClass({\n\t  displayName: 'editor.react',\n\t\n\t  getInitialState: function getInitialState() {\n\t    return { __html: '' };\n\t  },\n\t  componentDidMount: function componentDidMount() {\n\t    // check dom node\n\t    this.textControl = _react2['default'].findDOMNode(this.refs.editor);\n\t    this.previewControl = _react2['default'].findDOMNode(this.refs.preview);\n\t  },\n\t  render: function render() {\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'md-panel' },\n\t      _react2['default'].createElement('div', { className: 'md-toolbar' }),\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'md-editor' },\n\t        _react2['default'].createElement('textarea', { ref: 'editor', onChange: this._onChange })\n\t      ),\n\t      _react2['default'].createElement('div', { ref: 'preview', className: 'md-preview', dangerouslySetInnerHTML: this.state }),\n\t      _react2['default'].createElement('div', { className: 'md-spliter' })\n\t    );\n\t  },\n\t  _onChange: function _onChange(e) {\n\t    var _this = this;\n\t\n\t    if (this._ltr) clearTimeout(this._ltr);\n\t\n\t    this._ltr = setTimeout(function () {\n\t      var input = _this.textControl.value;\n\t      _this.setState({ __html: (0, _marked2['default'])(input) });\n\t    }, 300);\n\t  }\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = marked;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** editor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5ec8d881bec3aa11bfe9\n **/","import React from 'react';\nimport EditorForm from './components/form.react';\n\nlet mount = document.getElementById('editor');\nReact.render(<EditorForm />, mount);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/editor.main.js\n **/","module.exports = React;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"React\"\n ** module id = 1\n ** module chunks = 0\n **/","import React from 'react';\nimport TagInput from './taginput.react';\nimport Editor from './editor.react';\n\nexport default React.createClass({\n  render: function() {\n    return (\n      <form>\n        <TagInput />\n        <Editor />\n      </form>\n    );\n  }\n});\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/components/form.react.jsx\n **/","/// <reference path=\"../../typings/react/react.d.ts\"/>\nimport React from 'react';\nimport tagStore, {setTags} from '../stores/taginput.store';\nimport tagActions from '../actions/taginput.action';\n\nexport default React.createClass({\n  getInitialState: function () {\n    return {\n      tags: this.props.tags || []\n    };\n  },\n  componentDidMount: function () {\n    let input = React.findDOMNode(this.refs.input);\n    this._initialInputWidth = this._getElementWidth(input);\n\n    // init tags\n    setTags(this.state.tags);\n    tagStore.listen(this._updateView);\n  },\n  render: function () {\n    let that = this;\n    let tags = this.state.tags.map((tag, i) => {\n      return (\n        <span key={i} className=\"tag\">\n          {tag}\n          <span className=\"tag-remove\" onClick={function() { tagActions.removeTag(i); }}> X</span>\n        </span>\n      );\n    });\n\n    return (\n      <div className=\"tag-input\" onClick={this._click}>\n        {tags}\n        <input type=\"text\" ref=\"input\" onKeyDown={this._keyDown} onKeyUp={this._keyUp} />\n        <span className=\"hidden\" ref=\"hidden\"></span>\n      </div>\n      );\n  },\n  _updateView: function (tags) {\n    this.setState({ tags: tags });\n  },\n  _click: function () {\n    let input = React.findDOMNode(this.refs.input);\n    input.focus();\n  },\n  _keyDown: function (e) {\n    let input = React.findDOMNode(this.refs.input);\n    \n    switch(e.keyCode) {\n      case 188: { // add tag if ','\n        e.preventDefault();  // prevent the input of ','\n          \n        let val = input.value.trim();\n        input.value = \"\";\n        input.style.width = this._initialInputWidth + \"px\";\n        tagActions.addTag(val);\n        break;\n      };\n      case 8: { // remove tag if 'del'\n        if(input.value == '') tagActions.removeTag();\n        break;\n      };\n      default: {\n        // dynamic adjust input width\n      };\n    }\n  },\n  _keyUp: function (e) {\n    let input = React.findDOMNode(this.refs.input);\n    let hidden = React.findDOMNode(this.refs.hidden);\n\n    hidden.textContent = input.value;\n\n    let wInput = this._getElementWidth(input);\n    let wHidden = this._getElementWidth(hidden);\n    if(wHidden + 20 > wInput) {\n      input.style.width = (wInput + 20) + \"px\";\n    }\n  },\n  _getElementWidth: function (elem) {\n    let rect = elem.getBoundingClientRect();\n    return rect.right - rect.left;\n  }\n});\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/components/taginput.react.jsx\n **/","import Reflux from 'reflux';\nimport tagActions from '../actions/taginput.action';\n\nlet tags = [];\n\nexport function getTags() {\n  return tags;\n}\n\nexport function setTags(newTags) {\n  if(Object.prototype.toString.call(tags) == '[object Array]') {\n    tags = newTags;\n  }\n}\n\nexport default Reflux.createStore({\n  init: function() {\n    this.listenToMany(tagActions);\n  },\n  onAddTag: function(newTag) {\n    if(newTag && tags.indexOf(newTag) < 0) {\n      tags.push(newTag);\n      this.trigger(tags);\n    }\n  },\n  onRemoveTag: function(index) {\n    if(typeof index == 'undefined') {\n      index = tags.length - 1;\n    }\n    tags.splice(index, 1);\n    this.trigger(tags);\n  }\n});\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/stores/taginput.store.js\n **/","module.exports = require('./src');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/index.js\n ** module id = 5\n ** module chunks = 0\n **/","exports.ActionMethods = require('./ActionMethods');\n\nexports.ListenerMethods = require('./ListenerMethods');\n\nexports.PublisherMethods = require('./PublisherMethods');\n\nexports.StoreMethods = require('./StoreMethods');\n\nexports.createAction = require('./createAction');\n\nexports.createStore = require('./createStore');\n\nexports.connect = require('./connect');\n\nexports.connectFilter = require('./connectFilter');\n\nexports.ListenerMixin = require('./ListenerMixin');\n\nexports.listenTo = require('./listenTo');\n\nexports.listenToMany = require('./listenToMany');\n\n\nvar maker = require('./joins').staticJoinCreator;\n\nexports.joinTrailing = exports.all = maker(\"last\"); // Reflux.all alias for backward compatibility\n\nexports.joinLeading = maker(\"first\");\n\nexports.joinStrict = maker(\"strict\");\n\nexports.joinConcat = maker(\"all\");\n\nvar _ = require('./utils');\n\nexports.EventEmitter = _.EventEmitter;\n\nexports.Promise = _.Promise;\n\n/**\n * Convenience function for creating a set of actions\n *\n * @param definitions the definitions for the actions to be created\n * @returns an object with actions of corresponding action names\n */\nexports.createActions = function(definitions) {\n    var actions = {};\n    for (var k in definitions){\n        if (definitions.hasOwnProperty(k)) {\n            var val = definitions[k],\n                actionName = _.isObject(val) ? k : val;\n\n            actions[actionName] = exports.createAction(val);\n        }\n    }\n    return actions;\n};\n\n/**\n * Sets the eventmitter that Reflux uses\n */\nexports.setEventEmitter = function(ctx) {\n    var _ = require('./utils');\n    exports.EventEmitter = _.EventEmitter = ctx;\n};\n\n\n/**\n * Sets the Promise library that Reflux uses\n */\nexports.setPromise = function(ctx) {\n    var _ = require('./utils');\n    exports.Promise = _.Promise = ctx;\n};\n\n\n/**\n * Sets the Promise factory that creates new promises\n * @param {Function} factory has the signature `function(resolver) { return [new Promise]; }`\n */\nexports.setPromiseFactory = function(factory) {\n    var _ = require('./utils');\n    _.createPromise = factory;\n};\n\n\n/**\n * Sets the method used for deferring actions and stores\n */\nexports.nextTick = function(nextTick) {\n    var _ = require('./utils');\n    _.nextTick = nextTick;\n};\n\n/**\n * Provides the set of created actions and stores for introspection\n */\nexports.__keep = require('./Keep');\n\n/**\n * Warn if Function.prototype.bind not available\n */\nif (!Function.prototype.bind) {\n  console.error(\n    'Function.prototype.bind not available. ' +\n    'ES5 shim required. ' +\n    'https://github.com/spoike/refluxjs#es5'\n  );\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/index.js\n ** module id = 6\n ** module chunks = 0\n **/","var Reflux = require('./index');\n\n\n/**\n * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\n * without having to manually set listeners in the `componentDidMount` method.\n *\n * @param {Action|Store} listenable An Action or Store that should be\n *  listened to.\n * @param {Function|String} callback The callback to register as event handler\n * @param {Function|String} defaultCallback The callback to register as default handler\n * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\n */\nmodule.exports = function(listenable,callback,initial){\n    return {\n        /**\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n         * and then make the call to `listenTo` with the arguments provided to the factory function\n         */\n        componentDidMount: function() {\n            for(var m in Reflux.ListenerMethods){\n                if (this[m] !== Reflux.ListenerMethods[m]){\n                    if (this[m]){\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenTo!\";\n                    }\n                    this[m] = Reflux.ListenerMethods[m];\n                }\n            }\n            this.listenTo(listenable,callback,initial);\n        },\n        /**\n         * Cleans up all listener previously registered.\n         */\n        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/listenTo.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * A module of methods that you want to include in all actions.\n * This module is consumed by `createAction`.\n */\nmodule.exports = {\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ActionMethods.js\n ** module id = 8\n ** module chunks = 0\n **/","var _ = require('./utils'),\n    maker = require('./joins').instanceJoinCreator;\n\n/**\n * Extract child listenables from a parent from their\n * children property and return them in a keyed Object\n *\n * @param {Object} listenable The parent listenable\n */\nvar mapChildListenables = function(listenable) {\n    var i = 0, children = {}, childName;\n    for (;i < (listenable.children||[]).length; ++i) {\n        childName = listenable.children[i];\n        if(listenable[childName]){\n            children[childName] = listenable[childName];\n        }\n    }\n    return children;\n};\n\n/**\n * Make a flat dictionary of all listenables including their\n * possible children (recursively), concatenating names in camelCase.\n *\n * @param {Object} listenables The top-level listenables\n */\nvar flattenListenables = function(listenables) {\n    var flattened = {};\n    for(var key in listenables){\n        var listenable = listenables[key];\n        var childMap = mapChildListenables(listenable);\n\n        // recursively flatten children\n        var children = flattenListenables(childMap);\n\n        // add the primary listenable and chilren\n        flattened[key] = listenable;\n        for(var childKey in children){\n            var childListenable = children[childKey];\n            flattened[key + _.capitalize(childKey)] = childListenable;\n        }\n    }\n\n    return flattened;\n};\n\n/**\n * A module of methods related to listening.\n */\nmodule.exports = {\n\n    /**\n     * An internal utility function used by `validateListening`\n     *\n     * @param {Action|Store} listenable The listenable we want to search for\n     * @returns {Boolean} The result of a recursive search among `this.subscriptions`\n     */\n    hasListener: function(listenable) {\n        var i = 0, j, listener, listenables;\n        for (;i < (this.subscriptions||[]).length; ++i) {\n            listenables = [].concat(this.subscriptions[i].listenable);\n            for (j = 0; j < listenables.length; j++){\n                listener = listenables[j];\n                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    /**\n     * A convenience method that listens to all listenables in the given object.\n     *\n     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\n     */\n    listenToMany: function(listenables){\n        var allListenables = flattenListenables(listenables);\n        for(var key in allListenables){\n            var cbname = _.callbackName(key),\n                localname = this[cbname] ? cbname : this[key] ? key : undefined;\n            if (localname){\n                this.listenTo(allListenables[key],localname,this[cbname+\"Default\"]||this[localname+\"Default\"]||localname);\n            }\n        }\n    },\n\n    /**\n     * Checks if the current context can listen to the supplied listenable\n     *\n     * @param {Action|Store} listenable An Action or Store that should be\n     *  listened to.\n     * @returns {String|Undefined} An error message, or undefined if there was no problem.\n     */\n    validateListening: function(listenable){\n        if (listenable === this) {\n            return \"Listener is not able to listen to itself\";\n        }\n        if (!_.isFunction(listenable.listen)) {\n            return listenable + \" is missing a listen method\";\n        }\n        if (listenable.hasListener && listenable.hasListener(this)) {\n            return \"Listener cannot listen to this listenable because of circular loop\";\n        }\n    },\n\n    /**\n     * Sets up a subscription to the given listenable for the context object\n     *\n     * @param {Action|Store} listenable An Action or Store that should be\n     *  listened to.\n     * @param {Function|String} callback The callback to register as event handler\n     * @param {Function|String} defaultCallback The callback to register as default handler\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\n     */\n    listenTo: function(listenable, callback, defaultCallback) {\n        var desub, unsubscriber, subscriptionobj, subs = this.subscriptions = this.subscriptions || [];\n        _.throwIf(this.validateListening(listenable));\n        this.fetchInitialState(listenable, defaultCallback);\n        desub = listenable.listen(this[callback]||callback, this);\n        unsubscriber = function() {\n            var index = subs.indexOf(subscriptionobj);\n            _.throwIf(index === -1,'Tried to remove listen already gone from subscriptions list!');\n            subs.splice(index, 1);\n            desub();\n        };\n        subscriptionobj = {\n            stop: unsubscriber,\n            listenable: listenable\n        };\n        subs.push(subscriptionobj);\n        return subscriptionobj;\n    },\n\n    /**\n     * Stops listening to a single listenable\n     *\n     * @param {Action|Store} listenable The action or store we no longer want to listen to\n     * @returns {Boolean} True if a subscription was found and removed, otherwise false.\n     */\n    stopListeningTo: function(listenable){\n        var sub, i = 0, subs = this.subscriptions || [];\n        for(;i < subs.length; i++){\n            sub = subs[i];\n            if (sub.listenable === listenable){\n                sub.stop();\n                _.throwIf(subs.indexOf(sub)!==-1,'Failed to remove listen from subscriptions list!');\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Stops all subscriptions and empties subscriptions array\n     */\n    stopListeningToAll: function(){\n        var remaining, subs = this.subscriptions || [];\n        while((remaining=subs.length)){\n            subs[0].stop();\n            _.throwIf(subs.length!==remaining-1,'Failed to remove listen from subscriptions list!');\n        }\n    },\n\n    /**\n     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\n     * @param {Action|Store} listenable The publisher we want to get initial state from\n     * @param {Function|String} defaultCallback The method to receive the data\n     */\n    fetchInitialState: function (listenable, defaultCallback) {\n        defaultCallback = (defaultCallback && this[defaultCallback]) || defaultCallback;\n        var me = this;\n        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n            var data = listenable.getInitialState();\n            if (data && _.isFunction(data.then)) {\n                data.then(function() {\n                    defaultCallback.apply(me, arguments);\n                });\n            } else {\n                defaultCallback.call(this, data);\n            }\n        }\n    },\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the last emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinTrailing: maker(\"last\"),\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the first emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinLeading: maker(\"first\"),\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with all emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinConcat: maker(\"all\"),\n\n    /**\n     * The callback will be called once all listenables have triggered.\n     * If a callback triggers twice before that happens, an error is thrown.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinStrict: maker(\"strict\")\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ListenerMethods.js\n ** module id = 9\n ** module chunks = 0\n **/","/*\n * isObject, extend, isFunction, isArguments are taken from undescore/lodash in\n * order to remove the dependency\n */\nvar isObject = exports.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n};\n\nexports.extend = function(obj) {\n    if (!isObject(obj)) {\n        return obj;\n    }\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n                Object.defineProperty(obj, prop, propertyDescriptor);\n            } else {\n                obj[prop] = source[prop];\n            }\n        }\n    }\n    return obj;\n};\n\nexports.isFunction = function(value) {\n    return typeof value === 'function';\n};\n\nexports.EventEmitter = require('eventemitter3');\n\nexports.nextTick = function(callback) {\n    setTimeout(callback, 0);\n};\n\nexports.capitalize = function(string){\n    return string.charAt(0).toUpperCase()+string.slice(1);\n};\n\nexports.callbackName = function(string){\n    return \"on\"+exports.capitalize(string);\n};\n\nexports.object = function(keys,vals){\n    var o={}, i=0;\n    for(;i<keys.length;i++){\n        o[keys[i]] = vals[i];\n    }\n    return o;\n};\n\nexports.Promise = require(\"native-promise-only\");\n\nexports.createPromise = function(resolver) {\n    return new exports.Promise(resolver);\n};\n\nexports.isArguments = function(value) {\n    return typeof value === 'object' && ('callee' in value) && typeof value.length === 'number';\n};\n\nexports.throwIf = function(val,msg){\n    if (val){\n        throw Error(msg||val);\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/utils.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/~/eventemitter3/index.js\n ** module id = 11\n ** module chunks = 0\n **/","/*! Native Promise Only\n    v0.7.6-a (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n!function(t,n,e){n[t]=n[t]||e(),\"undefined\"!=typeof module&&module.exports?module.exports=n[t]:\"function\"==typeof define&&define.amd&&define(function(){return n[t]})}(\"Promise\",\"undefined\"!=typeof global?global:this,function(){\"use strict\";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||\"object\"!=e&&\"function\"!=e||(n=t.then),\"function\"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError(\"Promise-chain cycle\")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u,a=this;if(!a.triggered){a.triggered=!0,a.def&&(a=a.def);try{(c=n(o))?(u=new f(a),c.call(o,function(){r.apply(u,arguments)},function(){i.apply(u,arguments)})):(a.msg=o,a.state=1,a.chain.length>0&&t(e,a))}catch(s){i.call(u||new f(a),s)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if(\"function\"!=typeof n)throw TypeError(\"Not a function\");if(0!==this.__NPO__)throw TypeError(\"Not a promise\");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:\"function\"==typeof n?n:!0,failure:\"function\"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if(\"function\"!=typeof t||\"function\"!=typeof n)throw TypeError(\"Not a function\");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this[\"catch\"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y=\"undefined\"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},\"x\",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},\"constructor\",a,!1);return s(a,\"prototype\",g,!1),s(g,\"__NPO__\",0,!1),s(a,\"resolve\",function(t){var n=this;return t&&\"object\"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");n(t)})}),s(a,\"reject\",function(t){return new this(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");e(t)})}),s(a,\"all\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):0===t.length?n.resolve([]):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,\"race\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");c(n,t,function(t,n){e(n)},o)})}),a});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/~/native-promise-only/npo.js\n ** module id = 12\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 13\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/process/browser.js\n ** module id = 14\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Internal module used to create static and instance join methods\n */\n\nvar slice = Array.prototype.slice,\n    _ = require(\"./utils\"),\n    createStore = require(\"./createStore\"),\n    strategyMethodNames = {\n        strict: \"joinStrict\",\n        first: \"joinLeading\",\n        last: \"joinTrailing\",\n        all: \"joinConcat\"\n    };\n\n/**\n * Used in `index.js` to create the static join methods\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\n */\nexports.staticJoinCreator = function(strategy){\n    return function(/* listenables... */) {\n        var listenables = slice.call(arguments);\n        return createStore({\n            init: function(){\n                this[strategyMethodNames[strategy]].apply(this,listenables.concat(\"triggerAsync\"));\n            }\n        });\n    };\n};\n\n/**\n * Used in `ListenerMethods.js` to create the instance join methods\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\n */\nexports.instanceJoinCreator = function(strategy){\n    return function(/* listenables..., callback*/){\n        _.throwIf(arguments.length < 3,'Cannot create a join with less than 2 listenables!');\n        var listenables = slice.call(arguments),\n            callback = listenables.pop(),\n            numberOfListenables = listenables.length,\n            join = {\n                numberOfListenables: numberOfListenables,\n                callback: this[callback]||callback,\n                listener: this,\n                strategy: strategy\n            }, i, cancels = [], subobj;\n        for (i = 0; i < numberOfListenables; i++) {\n            _.throwIf(this.validateListening(listenables[i]));\n        }\n        for (i = 0; i < numberOfListenables; i++) {\n            cancels.push(listenables[i].listen(newListener(i,join),this));\n        }\n        reset(join);\n        subobj = {listenable: listenables};\n        subobj.stop = makeStopper(subobj,cancels,this);\n        this.subscriptions = (this.subscriptions || []).concat(subobj);\n        return subobj;\n    };\n};\n\n// ---- internal join functions ----\n\nfunction makeStopper(subobj,cancels,context){\n    return function() {\n        var i, subs = context.subscriptions,\n            index = (subs ? subs.indexOf(subobj) : -1);\n        _.throwIf(index === -1,'Tried to remove join already gone from subscriptions list!');\n        for(i=0;i < cancels.length; i++){\n            cancels[i]();\n        }\n        subs.splice(index, 1);\n    };\n}\n\nfunction reset(join) {\n    join.listenablesEmitted = new Array(join.numberOfListenables);\n    join.args = new Array(join.numberOfListenables);\n}\n\nfunction newListener(i,join) {\n    return function() {\n        var callargs = slice.call(arguments);\n        if (join.listenablesEmitted[i]){\n            switch(join.strategy){\n                case \"strict\": throw new Error(\"Strict join failed because listener triggered twice.\");\n                case \"last\": join.args[i] = callargs; break;\n                case \"all\": join.args[i].push(callargs);\n            }\n        } else {\n            join.listenablesEmitted[i] = true;\n            join.args[i] = (join.strategy===\"all\"?[callargs]:callargs);\n        }\n        emitIfAllListenablesEmitted(join);\n    };\n}\n\nfunction emitIfAllListenablesEmitted(join) {\n    for (var i = 0; i < join.numberOfListenables; i++) {\n        if (!join.listenablesEmitted[i]) {\n            return;\n        }\n    }\n    join.callback.apply(join.listener,join.args);\n    reset(join);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/joins.js\n ** module id = 16\n ** module chunks = 0\n **/","var _ = require('./utils'),\n    Reflux = require('./index'),\n    Keep = require('./Keep'),\n    mixer = require('./mixer'),\n    allowed = {preEmit:1,shouldEmit:1},\n    bindMethods = require('./bindMethods');\n\n/**\n * Creates an event emitting Data Store. It is mixed in with functions\n * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\n * and `shouldEmit` may be overridden in the definition object.\n *\n * @param {Object} definition The data store object definition\n * @returns {Store} A data store instance\n */\nmodule.exports = function(definition) {\n\n    definition = definition || {};\n\n    for(var a in Reflux.StoreMethods){\n        if (!allowed[a] && (Reflux.PublisherMethods[a] || Reflux.ListenerMethods[a])){\n            throw new Error(\"Cannot override API method \" + a +\n                \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n            );\n        }\n    }\n\n    for(var d in definition){\n        if (!allowed[d] && (Reflux.PublisherMethods[d] || Reflux.ListenerMethods[d])){\n            throw new Error(\"Cannot override API method \" + d +\n                \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n            );\n        }\n    }\n\n    definition = mixer(definition);\n\n    function Store() {\n        var i=0, arr;\n        this.subscriptions = [];\n        this.emitter = new _.EventEmitter();\n        this.eventLabel = \"change\";\n        bindMethods(this, definition);\n        if (this.init && _.isFunction(this.init)) {\n            this.init();\n        }\n        if (this.listenables){\n            arr = [].concat(this.listenables);\n            for(;i < arr.length;i++){\n                this.listenToMany(arr[i]);\n            }\n        }\n    }\n\n    _.extend(Store.prototype, Reflux.ListenerMethods, Reflux.PublisherMethods, Reflux.StoreMethods, definition);\n\n    var store = new Store();\n    Keep.createdStores.push(store);\n\n    return store;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/createStore.js\n ** module id = 17\n ** module chunks = 0\n **/","exports.createdStores = [];\n\nexports.createdActions = [];\n\nexports.reset = function() {\n    while(exports.createdStores.length) {\n        exports.createdStores.pop();\n    }\n    while(exports.createdActions.length) {\n        exports.createdActions.pop();\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/Keep.js\n ** module id = 18\n ** module chunks = 0\n **/","var _ = require('./utils');\n\nmodule.exports = function mix(def) {\n    var composed = {\n        init: [],\n        preEmit: [],\n        shouldEmit: []\n    };\n\n    var updated = (function mixDef(mixin) {\n        var mixed = {};\n        if (mixin.mixins) {\n            mixin.mixins.forEach(function (subMixin) {\n                _.extend(mixed, mixDef(subMixin));\n            });\n        }\n        _.extend(mixed, mixin);\n        Object.keys(composed).forEach(function (composable) {\n            if (mixin.hasOwnProperty(composable)) {\n                composed[composable].push(mixin[composable]);\n            }\n        });\n        return mixed;\n    }(def));\n\n    if (composed.init.length > 1) {\n        updated.init = function () {\n            var args = arguments;\n            composed.init.forEach(function (init) {\n                init.apply(this, args);\n            }, this);\n        };\n    }\n    if (composed.preEmit.length > 1) {\n        updated.preEmit = function () {\n            return composed.preEmit.reduce(function (args, preEmit) {\n                var newValue = preEmit.apply(this, args);\n                return newValue === undefined ? args : [newValue];\n            }.bind(this), arguments);\n        };\n    }\n    if (composed.shouldEmit.length > 1) {\n        updated.shouldEmit = function () {\n            var args = arguments;\n            return !composed.shouldEmit.some(function (shouldEmit) {\n                return !shouldEmit.apply(this, args);\n            }, this);\n        };\n    }\n    Object.keys(composed).forEach(function (composable) {\n        if (composed[composable].length === 1) {\n            updated[composable] = composed[composable][0];\n        }\n    });\n\n    return updated;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/mixer.js\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = function(store, definition) {\n  for (var name in definition) {\n    if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n        var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);\n\n        if (!propertyDescriptor.value || typeof propertyDescriptor.value !== 'function' || !definition.hasOwnProperty(name)) {\n            continue;\n        }\n\n        store[name] = definition[name].bind(store);\n    } else {\n        var property = definition[name];\n\n        if (typeof property !== 'function' || !definition.hasOwnProperty(name)) {\n            continue;\n        }\n\n        store[name] = property.bind(store);\n    }\n  }\n\n  return store;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/bindMethods.js\n ** module id = 20\n ** module chunks = 0\n **/","var _ = require('./utils');\n\n/**\n * A module of methods for object that you want to be able to listen to.\n * This module is consumed by `createStore` and `createAction`\n */\nmodule.exports = {\n\n    /**\n     * Hook used by the publisher that is invoked before emitting\n     * and before `shouldEmit`. The arguments are the ones that the action\n     * is invoked with. If this function returns something other than\n     * undefined, that will be passed on as arguments for shouldEmit and\n     * emission.\n     */\n    preEmit: function() {},\n\n    /**\n     * Hook used by the publisher after `preEmit` to determine if the\n     * event should be emitted with given arguments. This may be overridden\n     * in your application, default implementation always returns true.\n     *\n     * @returns {Boolean} true if event should be emitted\n     */\n    shouldEmit: function() { return true; },\n\n    /**\n     * Subscribes the given callback for action triggered\n     *\n     * @param {Function} callback The callback to register as event handler\n     * @param {Mixed} [optional] bindContext The context to bind the callback with\n     * @returns {Function} Callback that unsubscribes the registered event handler\n     */\n    listen: function(callback, bindContext) {\n        bindContext = bindContext || this;\n        var eventHandler = function(args) {\n            if (aborted){\n                return;\n            }\n            callback.apply(bindContext, args);\n        }, me = this, aborted = false;\n        this.emitter.addListener(this.eventLabel, eventHandler);\n        return function() {\n            aborted = true;\n            me.emitter.removeListener(me.eventLabel, eventHandler);\n        };\n    },\n\n    /**\n     * Attach handlers to promise that trigger the completed and failed\n     * child publishers, if available.\n     *\n     * @param {Object} The promise to attach to\n     */\n    promise: function(promise) {\n        var me = this;\n\n        var canHandlePromise =\n            this.children.indexOf('completed') >= 0 &&\n            this.children.indexOf('failed') >= 0;\n\n        if (!canHandlePromise){\n            throw new Error('Publisher must have \"completed\" and \"failed\" child publishers');\n        }\n\n        promise.then(function(response) {\n            return me.completed(response);\n        }, function(error) {\n            return me.failed(error);\n        });\n    },\n\n    /**\n     * Subscribes the given callback for action triggered, which should\n     * return a promise that in turn is passed to `this.promise`\n     *\n     * @param {Function} callback The callback to register as event handler\n     */\n    listenAndPromise: function(callback, bindContext) {\n        var me = this;\n        bindContext = bindContext || this;\n        this.willCallPromise = (this.willCallPromise || 0) + 1;\n\n        var removeListen = this.listen(function() {\n\n            if (!callback) {\n                throw new Error('Expected a function returning a promise but got ' + callback);\n            }\n\n            var args = arguments,\n                promise = callback.apply(bindContext, args);\n            return me.promise.call(me, promise);\n        }, bindContext);\n\n        return function () {\n          me.willCallPromise--;\n          removeListen.call(me);\n        };\n\n    },\n\n    /**\n     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\n     */\n    trigger: function() {\n        var args = arguments,\n            pre = this.preEmit.apply(this, args);\n        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n        if (this.shouldEmit.apply(this, args)) {\n            this.emitter.emit(this.eventLabel, args);\n        }\n    },\n\n    /**\n     * Tries to publish the event on the next tick\n     */\n    triggerAsync: function(){\n        var args = arguments,me = this;\n        _.nextTick(function() {\n            me.trigger.apply(me, args);\n        });\n    },\n\n    /**\n     * Returns a Promise for the triggered action\n     *\n     * @return {Promise}\n     *   Resolved by completed child action.\n     *   Rejected by failed child action.\n     *   If listenAndPromise'd, then promise associated to this trigger.\n     *   Otherwise, the promise is for next child action completion.\n     */\n    triggerPromise: function(){\n        var me = this;\n        var args = arguments;\n\n        var canHandlePromise =\n            this.children.indexOf('completed') >= 0 &&\n            this.children.indexOf('failed') >= 0;\n\n        var promise = _.createPromise(function(resolve, reject) {\n            // If `listenAndPromise` is listening\n            // patch `promise` w/ context-loaded resolve/reject\n            if (me.willCallPromise) {\n                _.nextTick(function() {\n                    var old_promise_method = me.promise;\n                    me.promise = function (promise) {\n                        promise.then(resolve, reject);\n                        // Back to your regularly schedule programming.\n                        me.promise = old_promise_method;\n                        return me.promise.apply(me, arguments);\n                    };\n                    me.trigger.apply(me, args);\n                });\n                return;\n            }\n\n            if (canHandlePromise) {\n                var removeSuccess = me.completed.listen(function(args) {\n                    removeSuccess();\n                    removeFailed();\n                    resolve(args);\n                });\n\n                var removeFailed = me.failed.listen(function(args) {\n                    removeSuccess();\n                    removeFailed();\n                    reject(args);\n                });\n            }\n\n            me.triggerAsync.apply(me, args);\n\n            if (!canHandlePromise) {\n                resolve();\n            }\n        });\n\n        return promise;\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/PublisherMethods.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * A module of methods that you want to include in all stores.\n * This module is consumed by `createStore`.\n */\nmodule.exports = {\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/StoreMethods.js\n ** module id = 22\n ** module chunks = 0\n **/","var _ = require('./utils'),\n    Reflux = require('./index'),\n    Keep = require('./Keep'),\n    allowed = {preEmit:1,shouldEmit:1};\n\n/**\n * Creates an action functor object. It is mixed in with functions\n * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\n * be overridden in the definition object.\n *\n * @param {Object} definition The action object definition\n */\nvar createAction = function(definition) {\n\n    definition = definition || {};\n    if (!_.isObject(definition)){\n        definition = {actionName: definition};\n    }\n\n    for(var a in Reflux.ActionMethods){\n        if (!allowed[a] && Reflux.PublisherMethods[a]) {\n            throw new Error(\"Cannot override API method \" + a +\n                \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\"\n            );\n        }\n    }\n\n    for(var d in definition){\n        if (!allowed[d] && Reflux.PublisherMethods[d]) {\n            throw new Error(\"Cannot override API method \" + d +\n                \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\"\n            );\n        }\n    }\n\n    definition.children = definition.children || [];\n    if (definition.asyncResult){\n        definition.children = definition.children.concat([\"completed\",\"failed\"]);\n    }\n\n    var i = 0, childActions = {};\n    for (; i < definition.children.length; i++) {\n        var name = definition.children[i];\n        childActions[name] = createAction(name);\n    }\n\n    var context = _.extend({\n        eventLabel: \"action\",\n        emitter: new _.EventEmitter(),\n        _isAction: true\n    }, Reflux.PublisherMethods, Reflux.ActionMethods, definition);\n\n    var functor = function() {\n        return functor[functor.sync?\"trigger\":\"triggerPromise\"].apply(functor, arguments);\n    };\n\n    _.extend(functor,childActions,context);\n\n    Keep.createdActions.push(functor);\n\n    return functor;\n\n};\n\nmodule.exports = createAction;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/createAction.js\n ** module id = 23\n ** module chunks = 0\n **/","var Reflux = require('./index'),\n    _ = require('./utils');\n\nmodule.exports = function(listenable,key){\n    return {\n        getInitialState: function(){\n            if (!_.isFunction(listenable.getInitialState)) {\n                return {};\n            } else if (key === undefined) {\n                return listenable.getInitialState();\n            } else {\n                return _.object([key],[listenable.getInitialState()]);\n            }\n        },\n        componentDidMount: function(){\n            _.extend(this,Reflux.ListenerMethods);\n            var me = this, cb = (key === undefined ? this.setState : function(v){me.setState(_.object([key],[v]));});\n            this.listenTo(listenable,cb);\n        },\n        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/connect.js\n ** module id = 24\n ** module chunks = 0\n **/","var Reflux = require('./index'),\n  _ = require('./utils');\n\nmodule.exports = function(listenable, key, filterFunc) {\n    filterFunc = _.isFunction(key) ? key : filterFunc;\n    return {\n        getInitialState: function() {\n            if (!_.isFunction(listenable.getInitialState)) {\n                return {};\n            } else if (_.isFunction(key)) {\n                return filterFunc.call(this, listenable.getInitialState());\n            } else {\n                // Filter initial payload from store.\n                var result = filterFunc.call(this, listenable.getInitialState());\n                if (result) {\n                  return _.object([key], [result]);\n                } else {\n                  return {};\n                }\n            }\n        },\n        componentDidMount: function() {\n            _.extend(this, Reflux.ListenerMethods);\n            var me = this;\n            var cb = function(value) {\n                if (_.isFunction(key)) {\n                    me.setState(filterFunc.call(me, value));\n                } else {\n                    var result = filterFunc.call(me, value);\n                    me.setState(_.object([key], [result]));\n                }\n            };\n\n            this.listenTo(listenable, cb);\n        },\n        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n    };\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/connectFilter.js\n ** module id = 25\n ** module chunks = 0\n **/","var _ = require('./utils'),\n    ListenerMethods = require('./ListenerMethods');\n\n/**\n * A module meant to be consumed as a mixin by a React component. Supplies the methods from\n * `ListenerMethods` mixin and takes care of teardown of subscriptions.\n * Note that if you're using the `connect` mixin you don't need this mixin, as connect will\n * import everything this mixin contains!\n */\nmodule.exports = _.extend({\n\n    /**\n     * Cleans up all listener previously registered.\n     */\n    componentWillUnmount: ListenerMethods.stopListeningToAll\n\n}, ListenerMethods);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ListenerMixin.js\n ** module id = 26\n ** module chunks = 0\n **/","var Reflux = require('./index');\n\n/**\n * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\n * without having to manually set listeners in the `componentDidMount` method. This version is used\n * to automatically set up a `listenToMany` call.\n *\n * @param {Object} listenables An object of listenables\n * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\n */\nmodule.exports = function(listenables){\n    return {\n        /**\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n         * and then make the call to `listenTo` with the arguments provided to the factory function\n         */\n        componentDidMount: function() {\n            for(var m in Reflux.ListenerMethods){\n                if (this[m] !== Reflux.ListenerMethods[m]){\n                    if (this[m]){\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenToMany!\";\n                    }\n                    this[m] = Reflux.ListenerMethods[m];\n                }\n            }\n            this.listenToMany(listenables);\n        },\n        /**\n         * Cleans up all listener previously registered.\n         */\n        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/listenToMany.js\n ** module id = 27\n ** module chunks = 0\n **/","import Reflux from 'reflux';\n\nexport default Reflux.createActions([\n  'addTag', 'removeTag'\n]);\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/actions/taginput.action.js\n **/","import React from 'react';\nimport marked from 'marked';\n\nexport default React.createClass({\n  getInitialState: function() {\n    return { __html: '' };\n  },\n  componentDidMount: function() {\n    // check dom node\n    this.textControl = React.findDOMNode(this.refs.editor);\n    this.previewControl = React.findDOMNode(this.refs.preview);\n  },\n  render: function() {\n    return (\n      <div className=\"md-panel\">\n        <div className=\"md-toolbar\"></div>\n        <div className=\"md-editor\">\n          <textarea ref=\"editor\" onChange={this._onChange}></textarea>\n        </div>\n        <div ref=\"preview\" className=\"md-preview\" dangerouslySetInnerHTML={this.state}></div>\n        <div className=\"md-spliter\"></div>\n      </div>\n    );\n  },\n  _onChange: function(e) {\n    if(this._ltr) clearTimeout(this._ltr);\n\n    this._ltr = setTimeout(() => {\n      let input = this.textControl.value;\n      this.setState({ __html: marked(input) });\n    }, 300);\n  }\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/components/editor.react.jsx\n **/","module.exports = marked;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"marked\"\n ** module id = 30\n ** module chunks = 0\n **/"],"sourceRoot":""}